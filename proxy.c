#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <pthread.h>

void error(char* msg)
{
  perror(msg);
  exit(0);
}

// Do string manipulation to remove special characters
// characters to remove: $-_.+!*'(),
// temp contains the resource
// remove_character(temp, '!');
void remove_character(char* str, char c) {
    char *pr = str, *pw = str;
    while (*pr) {
        *pw = *pr++;
        pw += (*pw != c);
    }
    *pw = '\0';
}



// Write only if header has been bypassed
// if (out) {
//   fprintf(out, "%s", buffer);
// }
// // If header has not been found. Search for it
// else {
//   // printf("%s\n",buffer);
//   if (strstr(buffer, "\r\n\r\n") != NULL) {
//     // Set up file to print out to and print out.
//     if (!out) {
//       // file_name = strcat(domain,".html");
//       // file_name = domain;
//       out = fopen(domain, "w");
//     }
//     fprintf(out, "%s", strstr(buffer, "\r\n\r\n")+ 4);
//   }
// }

int main(int argc, char *argv[]) {
  // pthread_mutex_t var=PTHREAD_MUTEX_INITIALIZER;
  pid_t pid;
  struct sockaddr_in addr_in,cli_addr,serv_addr;
  int sockfd,newsockfd;
  struct stat st = {0};

  if (argc < 2) {
    fprintf(stderr,"ERROR, no port provided\n");
    exit(1);
  }
  int proxy_port = atoi(argv[1]);
  printf("Starting a proxy on port %d\n", proxy_port);

  // Set up the server socket
  bzero((char *) &serv_addr, sizeof(serv_addr));
  sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if(sockfd < 0) {
    error("Problem initializing socket");
  }
  // Set up the server internet address struct
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  serv_addr.sin_port = htons(proxy_port);
  // Bind the socket to the server internet address struct
  if(bind(sockfd,(struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
    error("Problem binding socket");
  }
  // Start listening on the socket
  listen(sockfd,50);

  // Begin waiting for incoming connections
  unsigned int clilen = sizeof(cli_addr);
  bzero((char *) &cli_addr, clilen);
  while (1) {
    // Set up the client socket & wait for request
    newsockfd = accept(sockfd, (struct sockaddr*) &cli_addr, &clilen);  
    if(newsockfd < 0) {
      error("Problem accepting connection");
    }
    // Fork off a thread to execute request
    pid = fork();
    if (pid == 0) { 
      struct sockaddr_in remote_addr;
      int sockfd1, sockfd2;
      char buffer[512], req_type[256], domain[256], version[16], filename[256];
      char* temp = NULL;
      // Receive the get request
      bzero((char*)buffer, 512);
      read(newsockfd, buffer, 512);
      // Pull out the HTTP request components
      sscanf(buffer, "%s %s %s", req_type, domain, version);
         
      // Check that you have an HTTP GET request
      if(((strncmp(req_type, "GET", 3) == 0)) && (strncmp(version, "HTTP/1.", 7) == 0) && (strncmp(domain, "http://", 7) == 0)) {
        // Extract the host from request
        strcpy(req_type, domain); 
        temp = strtok(domain, "//");
        temp = strtok(NULL, "/");
        sprintf(domain, "%s", temp);
        printf("Host: %s\n", domain);
        struct hostent* host = gethostbyname(domain);
           
        // Extract the resource path
        // req_type contains the copied server address
        strcat(req_type, "@@");
        temp = strtok(req_type, "//");
        temp = strtok(NULL, "/");
        if(temp != NULL)
          temp = strtok(NULL,"@@");
        printf("Path: %s\n", temp);
         
        // Set up client connection (Outgoing connection is HTTP/Port 80)
        bzero((char*)&remote_addr, sizeof(remote_addr));
        remote_addr.sin_port = htons(80);
        remote_addr.sin_family = AF_INET;
        bcopy((char*)host->h_addr, (char*)&remote_addr.sin_addr.s_addr, host->h_length);
         
        // Connect to external domain
        sockfd1 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
        sockfd2 = connect(sockfd1,(struct sockaddr*)&remote_addr, sizeof(struct sockaddr));
        if(sockfd2 < 0)
          error("Problem connecting to remote server");
  

        // Generating forwarding GET request
        bzero((char*)buffer, sizeof(buffer));
        if(temp != NULL) {
          sprintf(buffer,"GET /%s %s\r\nHost: %s\r\n\r\n", temp, version, domain);
        }
        else {
          sprintf(buffer,"GET / %s\r\nHost: %s\r\n\r\n", version, domain);
        }

        // Send request to remote server
        int n = write(sockfd1, buffer, strlen(buffer));
        // Forwarding back to the original client 
        if (n > 0) {
          // Read back the response and store it in a cache
          FILE* out = NULL;
          while (n > 0) {
            bzero((char*)buffer, 512);
            n = read(sockfd1, buffer, 512);
            if (n > 0) {
              // Send the response to the original client
              write(newsockfd, buffer, n);
              // Write file to disk
              // Write entire response to disk
              // Set up directory and file to print out to
              if (stat(domain, &st) == -1) {
                mkdir(domain, 0700);
                printf("Made a folder %s\n", domain);
              }
              if (!out) {
                bzero(filename, sizeof(filename));
                strcpy(filename, domain);
                strcat(filename, "/");
                if (temp) {
                  strcat(filename, temp);
                }
                else {
                  strcat(filename, "root");
                }
                out = fopen(filename, "w");
              }
              // Print out to file
              // fprintf(out, "%s", buffer);
              fwrite(buffer, sizeof(char), strlen(buffer), out);
            }
          }
          // Close the opened file
          if (out) {
            fclose(out);
          }
        }
        else {
          error("Problem writing to socket");
        }
      }
      else {
        write(newsockfd,"400 : BAD REQUEST\nONLY HTTP REQUESTS ALLOWED",18);
      }
      close(sockfd1);
      close(newsockfd);
      close(sockfd);
      _exit(0);
    }
    else {
      close(newsockfd);
    }
  }
  return 0;
}