#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>

void error(char* msg)
{
  perror(msg);
  exit(0);
}

// Do string manipulation to remove special characters
// characters to remove: $-_.+!*'(),
// temp contains the resource
// remove_character(temp, '!');
void remove_character(char* str, char c) {
  char *pr = str, *pw = str;
  while (*pr) {
    *pw = *pr++;
    pw += (*pw != c);
  }
  *pw = '\0';
}

int main(int argc, char *argv[]) {
  pid_t pid;
  struct sockaddr_in addr_in,cli_addr,serv_addr;
  int sockfd,newsockfd;

  // Gather VM info from the shell
  if (argc < 3) {
    fprintf(stderr,"ERROR, vmhostname or port is missing\n");
    exit(1);
  }
  int vm_port = atoi(argv[2]);
  char vm_ip[24];
  strcpy(vm_ip, argv[1]);
  int ctrl_port = 1110;
  printf("Starting a controller on port %d\n", ctrl_port);

  // Set up the server socket
  bzero((char *) &serv_addr, sizeof(serv_addr));
  sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if(sockfd < 0) {
    error("Problem initializing socket");
  }
  // Set up the server internet address struct
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  serv_addr.sin_port = htons(ctrl_port);
  // Bind the socket to the server internet address struct
  if(bind(sockfd,(struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
    error("Problem binding socket");
  }
  // Start listening on the socket
  listen(sockfd,50);

  // Begin waiting for incoming connections
  unsigned int clilen = sizeof(cli_addr);
  bzero((char *) &cli_addr, clilen);
  while (1) {
    // Set up the client socket & wait for request
    newsockfd = accept(sockfd, (struct sockaddr*) &cli_addr, &clilen);  
    if(newsockfd < 0) {
      error("Problem accepting connection");
    }
    // Fork off a thread to execute request
    pid = fork();
    if (pid == 0) { 
      struct sockaddr_in remote_addr;
      int sockfd1, sockfd2;
      char buffer[512], req_type[256], url[256], domain[256], version[16];
      char* temp = NULL;
      // Receive the get request
      bzero((char*)buffer, 512);
      read(newsockfd, buffer, 512);
      // Pull out the HTTP request components
      sscanf(buffer, "%s %s %s", req_type, url, version);
         
      // Check that you have an HTTP GET request
      if(((strncmp(req_type, "GET", 3) == 0)) && (strncmp(version, "HTTP/1.", 7) == 0) && (strncmp(url, "http://", 7) == 0)) {
        // Extract the host from request
        strcpy(req_type, url); 
        temp = strtok(req_type, "//");
        temp = strtok(NULL, "/");
        sprintf(domain, "%s", temp);
        printf("Host: %s\n", domain);
           
        // Extract the resource path
        // req_type contains the copied server address
        strcat(req_type, "@@");
        temp = strtok(req_type, "//");
        temp = strtok(NULL, "/");
        if(temp != NULL)
          temp = strtok(NULL,"@@");
        printf("Path: %s\n", temp);


        struct hostent* host = gethostbyname(vm_ip);
        // Set up connection to vm daemon
        bzero((char*)&remote_addr, sizeof(remote_addr));
        remote_addr.sin_port = htons(vm_port);
        remote_addr.sin_family = AF_INET;
        bcopy((char*)host->h_addr, (char*)&remote_addr.sin_addr.s_addr, host->h_length);
         
        // Connect to vm daemon
        sockfd1 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
        sockfd2 = connect(sockfd1,(struct sockaddr*)&remote_addr, sizeof(struct sockaddr));
        if(sockfd2 < 0) {
          error("Problem connecting to remote server");
        }

        // Send request to VM daemon
        printf("%s\n", url);
        int n = write(sockfd1, url, sizeof(url));
        // Forwarding back to the original client 
        if (n > 0) {
          // Read back the response
          bzero((char*)buffer, 512);
          n = read(sockfd1, buffer, 512);
          printf("%s\n", buffer);

          // No exploit detected
          FILE* in = NULL;
          if (buffer[0] == 'y') {
            // Send the cached response to the original client
            // Open the file and begin reading
            bzero(url, sizeof(url));
            strncpy(url, domain, sizeof(domain));
            strcat(url, "/");
            // Remove all '/' from the resource name
            if (temp) {
              remove_character(temp, '/');
              strcat(url, temp);
            }
            else {
              strcat(url, "root");
            }
            printf("%s\n", url);
            in = fopen(url, "wb");
          }
          // Exploit detected
          else {
            //Send the exploit_detected reponse to the original client
          }

          // Transmit loaded file back to browser
          n = fread(buffer, sizeof(char), sizeof(buffer), in);
          while (n > 0) {
            write(newsockfd, buffer, n);
            n = fread(buffer, sizeof(char), sizeof(buffer), in);
          }
        }
        else {
          error("Problem writing to socket");
        }
      }
      else {
        write(newsockfd,"400 : BAD REQUEST\nONLY HTTP REQUESTS ALLOWED",18);
      }
      close(sockfd1);
      close(newsockfd);
      close(sockfd);
      _exit(0);
    }
    else {
      close(newsockfd);
    }
  }
  return 0;
}