#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>

void error(char* msg)
{
  perror(msg);
  exit(0);
}

// Do string manipulation to remove special characters
// characters to remove: $-_.+!*'(),
// temp contains the resource
// remove_character(temp, '!');
void remove_character(char* str, char c) {
  char *pr = str, *pw = str;
  while (*pr) {
    *pw = *pr++;
    pw += (*pw != c);
  }
  *pw = '\0';
}

int main(int argc, char *argv[]) {
  pid_t pid;
  struct sockaddr_in addr_in,cli_addr,serv_addr;
  int sockfd,newsockfd;

  // Gather VM info from the shell
  if (argc < 3) {
    fprintf(stderr,"ERROR, vmhostname or port is missing\n");
    exit(1);
  }
  int vm_port = atoi(argv[2]);
  char vm_ip[24];
  strcpy(vm_ip, argv[1]);
  int ctrl_port = 1110;
  printf("Starting a controller on port %d\n", ctrl_port);

  // Set up the server socket
  bzero((char *) &serv_addr, sizeof(serv_addr));
  sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if(sockfd < 0) {
    error("Problem initializing socket");
  }
  // Set up the server internet address struct
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  serv_addr.sin_port = htons(ctrl_port);
  // Bind the socket to the server internet address struct
  if(bind(sockfd,(struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
    error("Problem binding socket");
  }
  // Start listening on the socket
  listen(sockfd,50);

  // Begin waiting for incoming connections
  unsigned int clilen = sizeof(cli_addr);
  bzero((char *) &cli_addr, clilen);
  while (1) {
    // Set up the client socket & wait for request
    newsockfd = accept(sockfd, (struct sockaddr*) &cli_addr, &clilen);  
    if(newsockfd < 0) {
      error("Problem accepting connection");
    }
    // Fork off a thread to execute request
    pid = fork();
    if (pid == 0) { 
      struct sockaddr_in remote_addr;
      int sockfd1, sockfd2;
      char buffer[512], req_type[256], url[256], url2[256], domain[256], version[16];
      char* temp = NULL;
      // Receive the get request
      bzero((char*)buffer, 512);
      read(newsockfd, buffer, 512);
      // Pull out the HTTP request components
      sscanf(buffer, "%s %s %s", req_type, url, version);
         
      // Check that you have an HTTP GET request
      if(((strncmp(req_type, "GET", 3) == 0)) && (strncmp(version, "HTTP/1.", 7) == 0) && (strncmp(url, "http://", 7) == 0)) {
        // Extract the host from request
        strncpy(url2, url, sizeof(url));
        strncpy(req_type, url, sizeof(url)); 
        temp = strtok(url, "//");
        temp = strtok(NULL, "/");
        sprintf(domain, "%s", temp);
        printf("Host: %s\n", domain);
           
        // Extract the resource path
        // req_type contains the copied server address
        strcat(req_type, "@@");
        temp = strtok(req_type, "//");
        temp = strtok(NULL, "/");
        if(temp != NULL)
          temp = strtok(NULL,"@@");
        printf("Path: %s\n", temp);

        // Concatenate strings to create filename
        strcat(domain, "/");
        if (temp) {
          remove_character(temp, '/');
          temp = strtok(temp, "?");
          strcat(domain, temp);
        }
        else {
          strcat(domain, "root");
        }

        // Tell the browser to chill
        FILE* in = NULL;
        int n;
        // // Accepted 202
        // in = fopen("202_Accepted", "rb");
        // // Transmit chill response file back to browser
        // n = fread(buffer, sizeof(char), sizeof(buffer), in);
        // while (n > 0) {
        //   write(newsockfd, buffer, n);
        //   n = fread(buffer, sizeof(char), sizeof(buffer), in);
        // }
        // if (in) {
        //   fclose(in);
        // }

        // Only send request to VM daemon if not already cached
        // File already cached
        // printf("Domain: %s\n", domain);
        if( access( domain, F_OK ) != -1 ) {
          printf("Found: %s\n", domain);
          in = fopen(domain, "rb");
          // Transmit cached file back to browser
          n = fread(buffer, sizeof(char), sizeof(buffer), in);
          while (n > 0) {
            write(newsockfd, buffer, n);
            n = fread(buffer, sizeof(char), sizeof(buffer), in);
          }
          if (in) {
            fclose(in);
          }
        } 
        // File is not already cached
        else {
          // Set up connection to vm daemon
          printf("Requesting: %s\n", url2);
          struct hostent* host = gethostbyname(vm_ip);
          bzero((char*)&remote_addr, sizeof(remote_addr));
          remote_addr.sin_port = htons(vm_port);
          remote_addr.sin_family = AF_INET;
          bcopy((char*)host->h_addr, (char*)&remote_addr.sin_addr.s_addr, host->h_length);
           
          // Connect to vm daemon
          sockfd1 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
          sockfd2 = connect(sockfd1,(struct sockaddr*)&remote_addr, sizeof(struct sockaddr));
          if(sockfd2 < 0) {
            error("Problem connecting to remote server");
          }

          // Send request to VM daemon
          // printf("URL to VM: %s\n", url);
          n = write(sockfd1, url2, sizeof(url2));
          // Forwarding back to the original client 
          if (n > 0) {
            // Read back the response
            bzero((char*)buffer, 512);
            n = read(sockfd1, buffer, 512);
            // printf("Response from VM: %s\n", buffer);
          }
          else {
            error("Problem writing to socket");
          }

          // Retransmission to original client
          // No malicious activity detected
          if (buffer[0] == 'y') {
            printf("Not malicious\n");
            // Send the cached response to the original client
            // Open the file and begin reading
            in = fopen(domain, "rb");
          }
          // Exploit detected
          else {
            printf("Malicious\n");
            //Send the exploit_detected reponse to the original client
            in = fopen("exploit_detected", "rb");
            // Delete the file so it wont get loaded from cache 
            remove(domain);
          }

          // Transmit loaded file back to browser
          n = fread(buffer, sizeof(char), sizeof(buffer), in);
          while (n > 0) {
            write(newsockfd, buffer, n);
            n = fread(buffer, sizeof(char), sizeof(buffer), in);
          }
          if (in) {
            fclose(in);
          }
        }
      }
      else {
        write(newsockfd,"400 : BAD REQUEST\nONLY HTTP REQUESTS ALLOWED",18);
      }
      close(sockfd1);
      close(newsockfd);
      close(sockfd);
      _exit(0);
    }
    else {
      close(newsockfd);
    }
  }
  return 0;
}